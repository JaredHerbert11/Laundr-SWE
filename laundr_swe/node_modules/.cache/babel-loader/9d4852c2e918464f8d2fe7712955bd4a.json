{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n} // $FlowFixMe\n\n\nvar NumberUtils = /*#__PURE__*/function () {\n  function NumberUtils() {\n    _classCallCheck(this, NumberUtils);\n  }\n\n  _createClass(NumberUtils, null, [{\n    key: \"getParsedValue\",\n    value: function getParsedValue(value, valueType) {\n      return valueType === 'integer' ? parseInt(value, 10) : parseFloat(value);\n    }\n  }, {\n    key: \"getValueWithPrecisionAsString\",\n    value: function getValueWithPrecisionAsString(value, valueType, precision, valueStr) {\n      if (valueType === 'integer') {\n        return value.toString();\n      }\n\n      var factor = Math.pow(10, precision);\n      var decimalValueStr = (Math.round(value * factor) / factor).toString();\n      return valueStr && valueStr[valueStr.length - 1] === '.' ? \"\".concat(decimalValueStr, \".\") : decimalValueStr;\n    }\n  }]);\n\n  return NumberUtils;\n}();\n\nexports.default = NumberUtils;","map":{"version":3,"sources":["../../src/utils/NumberUtils.js"],"names":["NumberUtils","value","valueType","parseInt","parseFloat","precision","valueStr","factor","decimalValueStr","Math"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;EAEA;;;IAGqBA,W;;;;;;;mCACGC,K,EAAeC,S,EAA8B;AACjE,aAAOA,SAAS,KAATA,SAAAA,GAA0BC,QAAQ,CAAA,KAAA,EAAlCD,EAAkC,CAAlCA,GAAgDE,UAAU,CAAjE,KAAiE,CAAjE;AACD;;;kDAGCH,K,EACAC,S,EACAG,S,EACAC,Q,EACQ;AACR,UAAIJ,SAAS,KAAb,SAAA,EAA6B;AAC3B,eAAOD,KAAK,CAAZ,QAAOA,EAAP;AACD;;AAED,UAAMM,MAAM,GAAA,IAAA,CAAA,GAAA,CAAA,EAAA,EAAZ,SAAY,CAAZ;AACA,UAAMC,eAAe,GAAG,CAACC,IAAI,CAAJA,KAAAA,CAAWR,KAAK,GAAhBQ,MAAAA,IAAD,MAAA,EAAxB,QAAwB,EAAxB;AACA,aAAOH,QAAQ,IAAIA,QAAQ,CAACA,QAAQ,CAARA,MAAAA,GAATA,CAAQ,CAARA,KAAZA,GAAAA,GAAAA,GAAAA,MAAAA,CAAAA,eAAAA,EAAAA,GAAAA,CAAAA,GAAP,eAAA;AACD","sourcesContent":["// @flow\n\n// $FlowFixMe\nimport type { ValueType } from '../types/Types';\n\nexport default class NumberUtils {\n  static getParsedValue(value: string, valueType: ValueType): number {\n    return valueType === 'integer' ? parseInt(value, 10) : parseFloat(value);\n  }\n\n  static getValueWithPrecisionAsString(\n    value: number,\n    valueType: ValueType,\n    precision: number,\n    valueStr?: string\n  ): string {\n    if (valueType === 'integer') {\n      return value.toString();\n    }\n\n    const factor = 10 ** precision;\n    const decimalValueStr = (Math.round(value * factor) / factor).toString();\n    return valueStr && valueStr[valueStr.length - 1] === '.' ? `${decimalValueStr}.` : decimalValueStr;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}